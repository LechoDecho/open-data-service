stages:
  - build
  - integrationtest
  - publish
  - deploy

services:
  - docker:18.09.7-dind

# For predefined environment variables see: https://docs.gitlab.com/ee/ci/variables/
variables:
  # Instruct Testcontainers to use the daemon of DinD.
  # See further: https://docs.gitlab.com/ee/ci/docker/using_docker_build.html
  DOCKER_HOST: "tcp://docker:2375"
  # Improve performance with overlayfs.
  # See further: https://docs.docker.com/storage/storagedriver/overlayfs-driver/
  # See further: https://docs.gitlab.com/ee/ci/docker/using_docker_build.html
  DOCKER_DRIVER: "overlay2"

  ADAPTER_DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/adapter
  AUTH_DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/auth
  UI_DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/ui
  SCHEDULER_DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/scheduler
  STORAGE_POSTGREST_DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/storage
  STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/storage-db-liquibase
  TRANSFORMATION_DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/transformation
  CORE_DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/core
  DEPLOYMENT_CI_DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/deployment-ci-image

  NAMESPACE: ods-${CI_COMMIT_REF_SLUG}
  BASE_URL: /ods/${CI_COMMIT_REF_SLUG}
  ENVIRONMENT_URL: http://131.188.64.170${BASE_URL}



# ----------------- ADAPTER SERVICE --------------------

# BUILD
build-adapter:
  stage: build
  image: docker:stable
  before_script:
    - cd adapter
  script:
    - docker build -t ${ADAPTER_DOCKER_IMAGE_NAME} .
    - mkdir image # Store built image for following CI steps
    - docker save ${ADAPTER_DOCKER_IMAGE_NAME} > image/adapter.tar
  artifacts:
    expire_in: 1 day
    paths:
      - ./adapter/image/adapter.tar

# INTEGRATION-TEST
integrationtest-adapter:
  stage: integrationtest
  image: mykiwi/docker
  dependencies:
    - build-adapter
  script:
    - docker load -i ./adapter/image/adapter.tar
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml build adapter-it
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up -d adapter
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up --exit-code-from adapter-it adapter-it
  after_script:
    - docker-compose logs
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml down

# PUBLISH
publish-docker-adapter:
  stage: publish
  image: docker:stable
  dependencies:
    - build-adapter
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd adapter
  script:
    - docker load -i image/adapter.tar
    # Tag as version and push
    - docker tag ${ADAPTER_DOCKER_IMAGE_NAME} ${ADAPTER_DOCKER_IMAGE_NAME}:${CI_COMMIT_REF_SLUG}
    - docker push ${ADAPTER_DOCKER_IMAGE_NAME}:${CI_COMMIT_REF_SLUG}
  except:
    - master

publish-docker-adapter-master:
  stage: publish
  image: docker:stable
  dependencies:
    - build-adapter
  when: manual
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd adapter
  script:
    - docker load -i image/adapter.tar
    - export ADAPTER_VERSION=$(cat ./src/main/resources/application.properties | grep "version =" | awk '{print $3}' | sed "s/[']//g")
    # Tag as version and push
    - docker tag ${ADAPTER_DOCKER_IMAGE_NAME} ${ADAPTER_DOCKER_IMAGE_NAME}:${ADAPTER_VERSION}
    - docker tag ${ADAPTER_DOCKER_IMAGE_NAME} ${ADAPTER_DOCKER_IMAGE_NAME}:latest
    - docker push ${ADAPTER_DOCKER_IMAGE_NAME}:${ADAPTER_VERSION}
    - docker push ${ADAPTER_DOCKER_IMAGE_NAME}:latest
  only:
    - master


# ----------------- AUTH SERVICE --------------------

# BUILD
build-auth:
  stage: build
  image: docker:stable
  before_script:
    - cd auth
  script:
    - docker build -t ${AUTH_DOCKER_IMAGE_NAME} .
    - mkdir image # Store built image for following CI steps
    - docker save ${AUTH_DOCKER_IMAGE_NAME} > image/auth.tar
  artifacts:
    expire_in: 1 day
    paths:
      - ./auth/image/auth.tar

# PUBLISH
publish-docker-auth:
  stage: publish
  image: docker:stable
  dependencies:
    - build-auth
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd auth
  script:
    - docker load -i image/auth.tar
    # Tag as version and push
    - docker tag ${AUTH_DOCKER_IMAGE_NAME} ${AUTH_DOCKER_IMAGE_NAME}:${CI_COMMIT_REF_SLUG}
    - docker push ${AUTH_DOCKER_IMAGE_NAME}:${CI_COMMIT_REF_SLUG}
  except:
    - master

# PUBLISH
publish-docker-auth-master:
  stage: publish
  image: docker:stable
  dependencies:
    - build-auth
  when: manual
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd auth
  script:
    - docker load -i image/auth.tar
    - export AUTH_VERSION=$(cat version.txt | grep "VERSION" | awk '{print $3}' | sed 's/[,"]//g')
    # Tag as version and push
    - docker tag ${AUTH_DOCKER_IMAGE_NAME} ${AUTH_DOCKER_IMAGE_NAME}:${AUTH_VERSION}
    - docker tag ${AUTH_DOCKER_IMAGE_NAME} ${AUTH_DOCKER_IMAGE_NAME}:latest
    - docker push ${AUTH_DOCKER_IMAGE_NAME}:${AUTH_VERSION}
    - docker push ${AUTH_DOCKER_IMAGE_NAME}:latest
  only:
    - master



# ----------------- UI SERVICE --------------------

# BUILD
build-ui:
  stage: build
  image: docker:stable
  before_script:
    - cd ui
  script:
    - "docker build -t ${UI_DOCKER_IMAGE_NAME} ."
    - mkdir image # Store built image for following CI steps
    - docker save ${UI_DOCKER_IMAGE_NAME} > image/ui.tar
  artifacts:
    expire_in: 1 day
    paths:
      - ./ui/image

# PUBLISH
publish-docker-ui:
  stage: publish
  image: docker:stable
  dependencies:
    - build-ui
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd ui
  script:
    - docker load -i ./image/ui.tar
    # Tag as version and push
    - docker tag ${UI_DOCKER_IMAGE_NAME} ${UI_DOCKER_IMAGE_NAME}:${CI_COMMIT_REF_SLUG}
    - docker push ${UI_DOCKER_IMAGE_NAME}:${CI_COMMIT_REF_SLUG}
  except:
    - master

publish-docker-ui-master:
  stage: publish
  image: docker:stable
  dependencies:
    - build-ui
  when: manual
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd ui
  script:
    - docker load -i ./image/ui.tar
    - export UI_VERSION=$(cat package.json | grep "version" | awk '{print $2}' | sed 's/[,"]//g')
    # Tag as version and push
    - docker tag ${UI_DOCKER_IMAGE_NAME} ${UI_DOCKER_IMAGE_NAME}:${UI_VERSION}
    - docker tag ${UI_DOCKER_IMAGE_NAME} ${UI_DOCKER_IMAGE_NAME}:latest
    - docker push ${UI_DOCKER_IMAGE_NAME}:${UI_VERSION}
    - docker push ${UI_DOCKER_IMAGE_NAME}:latest
  only:
    - master



# ----------------- Storage SERVICE --------------------

# BUILD
build-storage:
  stage: build
  image: docker:stable
  before_script:
    - cd storage
  script:
    - "docker build -t ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME} ./postgrest/"
    - "docker build -t ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME} ./liquibase/"
    - mkdir image # Store built image for following CI steps
    - docker save ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME} > image/storage_postgrest.tar
    - docker save ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME} > image/storage_liquibase.tar
  artifacts:
    expire_in: 1 day
    paths:
      - ./storage/image


# INTEGRATION-TEST
integrationtest-storage:
  stage: integrationtest
  image: mykiwi/docker
  dependencies:
    - build-storage
  script:
    - docker load -i ./storage/image/storage_postgrest.tar
    - docker load -i ./storage/image/storage_liquibase.tar
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml build storage-it
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up -d storage-db
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up storage-db-liquibase
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up -d storage
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up --exit-code-from storage-it storage-it
  after_script:
    - docker-compose logs
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml down


# PUBLISH
publish-docker-storage:
  stage: publish
  image: docker:stable
  dependencies:
    - build-storage
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd storage
  script:
    - docker load -i ./image/storage_postgrest.tar
    - docker load -i ./image/storage_liquibase.tar
    # Tag as version and push
    - docker tag ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME} ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME}:${CI_COMMIT_REF_SLUG}
    - docker tag ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME} ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME}:${CI_COMMIT_REF_SLUG}
    - docker push ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME}:${CI_COMMIT_REF_SLUG}
    - docker push ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME}:${CI_COMMIT_REF_SLUG}
  except:
    - master

publish-docker-storage-master:
  stage: publish
  image: docker:stable
  dependencies:
    - build-storage
  when: manual
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd storage
  script:
    - docker load -i ./image/storage_postgrest.tar
    - docker load -i ./image/storage_liquibase.tar
    - export STORAGE_VERSION=$(cat version.txt | grep "VERSION" | awk '{print $3}' | sed 's/[,"]//g')
    # Tag as version and push
    - docker tag ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME} ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME}:${STORAGE_VERSION}
    - docker tag ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME} ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME}:latest
    - docker tag ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME} ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME}:${STORAGE_VERSION}
    - docker tag ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME} ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME}:latest
    - docker push ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME}:${STORAGE_VERSION}
    - docker push ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME}:latest
    - docker push ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME}:${STORAGE_VERSION}
    - docker push ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME}:latest
  only:
    - master



# ----------------- CORE SERVICE --------------------

# BUILD
build-core:
  stage: build
  image: docker:stable
  before_script:
    - cd core
  script:
    - docker build -t ${CORE_DOCKER_IMAGE_NAME} .
    - mkdir image
    - docker save ${CORE_DOCKER_IMAGE_NAME} > image/core.tar
  artifacts:
    expire_in: 1 day
    paths:
      - ./core/image/core.tar

# INTEGRATION-TEST
integrationtest-core:
  stage: integrationtest
  image: mykiwi/docker
  dependencies:
    - build-core
  script:
    - docker load -i ./core/image/core.tar
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml build core-it
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up -d core
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up --exit-code-from core-it core-it
  after_script:
    - docker-compose logs
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml down


#PUBLISH
public-docker-core:
  stage: publish
  image: docker:stable
  dependencies:
    - build-core
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd core
  script:
    - docker load -i ./image/core.tar
    # Tag as version and push
    - docker tag ${CORE_DOCKER_IMAGE_NAME} ${CORE_DOCKER_IMAGE_NAME}:${CI_COMMIT_REF_SLUG}
    - docker push ${CORE_DOCKER_IMAGE_NAME}:${CI_COMMIT_REF_SLUG}
  except:
    - master

publish-docker-core-master:
  stage: publish
  image: docker:stable
  dependencies:
    - build-core
  when: manual
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd core
  script:
    - docker load -i ./image/core.tar
    - export CORE_VERSION=$(cat ./src/main/resources/application.properties | grep "version =" | awk '{print $3}' | sed "s/[']//g")
    # Tag as version and push
    - docker tag ${CORE_DOCKER_IMAGE_NAME} ${CORE_DOCKER_IMAGE_NAME}:${CORE_VERSION}
    - docker tag ${CORE_DOCKER_IMAGE_NAME} ${CORE_DOCKER_IMAGE_NAME}:latest
    - docker push ${CORE_DOCKER_IMAGE_NAME}:${CORE_VERSION}
    - docker push ${CORE_DOCKER_IMAGE_NAME}:latest
  only:
    - master



# ----------------- Scheduler SERVICE --------------------

# BUILD
build-scheduler:
  stage: build
  image: docker:stable
  before_script:
    - cd scheduler
  script:
    - "docker build -t ${SCHEDULER_DOCKER_IMAGE_NAME} ."
    - mkdir image # Store built image for following CI steps
    - docker save ${SCHEDULER_DOCKER_IMAGE_NAME} > image/scheduler.tar
  artifacts:
    expire_in: 1 day
    paths:
      - ./scheduler/image


# INTEGRATION-TEST
integrationtest-scheduler:
  stage: integrationtest
  image: mykiwi/docker
  dependencies:
    - build-scheduler
  script:
    - docker load -i ./scheduler/image/scheduler.tar
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml build scheduler-it
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up -d scheduler
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up --exit-code-from scheduler-it scheduler-it
  after_script:
    - docker-compose logs
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml down


# PUBLISH
publish-docker-scheduler:
  stage: publish
  image: docker:stable
  dependencies:
    - build-scheduler
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd scheduler
  script:
    - docker load -i ./image/scheduler.tar
    # Tag as version and push
    - docker tag ${SCHEDULER_DOCKER_IMAGE_NAME} ${SCHEDULER_DOCKER_IMAGE_NAME}:${CI_COMMIT_REF_SLUG}
    - docker push ${SCHEDULER_DOCKER_IMAGE_NAME}:${CI_COMMIT_REF_SLUG}
  except:
    - master

publish-docker-scheduler-master:
  stage: publish
  image: docker:stable
  dependencies:
    - build-scheduler
  when: manual
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd scheduler
  script:
    - docker load -i ./image/scheduler.tar
    - export SCHEDULER_VERSION=$(cat package.json | grep "version" | awk '{print $2}' | sed 's/[,"]//g')
    # Tag as version and push
    - docker tag ${SCHEDULER_DOCKER_IMAGE_NAME} ${SCHEDULER_DOCKER_IMAGE_NAME}:${SCHEDULER_VERSION}
    - docker tag ${SCHEDULER_DOCKER_IMAGE_NAME} ${SCHEDULER_DOCKER_IMAGE_NAME}:latest
    - docker push ${SCHEDULER_DOCKER_IMAGE_NAME}:${SCHEDULER_VERSION}
    - docker push ${SCHEDULER_DOCKER_IMAGE_NAME}:latest
  only:
    - master


# ----------------- Transformation SERVICE --------------------

# BUILD
build-transformation:
  stage: build
  image: docker:stable
  before_script:
    - cd transformation
  script:
    - "docker build -t ${TRANSFORMATION_DOCKER_IMAGE_NAME} ."
    - mkdir image # Store built image for following CI steps
    - docker save ${TRANSFORMATION_DOCKER_IMAGE_NAME} > image/transformation.tar
  artifacts:
    expire_in: 1 day
    paths:
      - ./transformation/image


# INTEGRATION-TEST
integrationtest-transformation:
  stage: integrationtest
  image: mykiwi/docker
  dependencies:
    - build-transformation
  script:
    - docker load -i ./transformation/image/transformation.tar
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml build transformation-it
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up -d transformation
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up --exit-code-from transformation-it transformation-it
  after_script:
    - docker-compose logs
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml down


# PUBLISH
publish-docker-transformation:
  stage: publish
  image: docker:stable
  dependencies:
    - build-transformation
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd transformation
  script:
    - docker load -i ./image/transformation.tar
    # Tag as version and push
    - docker tag ${TRANSFORMATION_DOCKER_IMAGE_NAME} ${TRANSFORMATION_DOCKER_IMAGE_NAME}:${CI_COMMIT_REF_SLUG}
    - docker push ${TRANSFORMATION_DOCKER_IMAGE_NAME}:${CI_COMMIT_REF_SLUG}
  except:
    - master

publish-docker-transformation-master:
  stage: publish
  image: docker:stable
  dependencies:
    - build-transformation
  when: manual
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd transformation
  script:
    - docker load -i ./image/transformation.tar
    - export TRANSFORMATION_VERSION=$(cat package.json | grep "version" | awk '{print $2}' | sed 's/[,"]//g')
    # Tag as version and push
    - docker tag ${TRANSFORMATION_DOCKER_IMAGE_NAME} ${TRANSFORMATION_DOCKER_IMAGE_NAME}:${TRANSFORMATION_VERSION}
    - docker tag ${TRANSFORMATION_DOCKER_IMAGE_NAME} ${TRANSFORMATION_DOCKER_IMAGE_NAME}:latest
    - docker push ${TRANSFORMATION_DOCKER_IMAGE_NAME}:${TRANSFORMATION_VERSION}
    - docker push ${TRANSFORMATION_DOCKER_IMAGE_NAME}:latest
  only:
    - master


# ------------------------ SYSTEM TEST ---------------------------------
system-test:
  stage: integrationtest
  image: mykiwi/docker
  script:
    - docker load -i ./core/image/core.tar
    - docker load -i ./scheduler/image/scheduler.tar
    - docker load -i ./storage/image/storage_postgrest.tar
    - docker load -i ./storage/image/storage_liquibase.tar
    - docker load -i ./transformation/image/transformation.tar
    - docker load -i ./adapter/image/adapter.tar
    - docker-compose -f docker-compose.yml up -d core adapter transformation storage scheduler
    - docker-compose -f docker-compose.yml -f docker-compose.st.yml up --exit-code-from system-test system-test
  after_script:
    - docker-compose logs
    - docker-compose -f docker-compose.yml -f docker-compose.st.yml down

#------------------------ DEPLOYMENT BASE IMAGE ----------------------------------#
# BUILD
build-deployment-ci-image:
  stage: build
  image: docker:stable
  before_script:
    - cd deployment/ci-base-image
  script:
    - "docker build -t ${DEPLOYMENT_CI_DOCKER_IMAGE_NAME} ."
    - docker save ${DEPLOYMENT_CI_DOCKER_IMAGE_NAME} > deployment-ci-image.tar
  artifacts:
    expire_in: 1 day
    paths:
      - deployment/ci-base-image
        
# PUBLISH
publish-deployment-ci-image:
  stage: publish
  image: docker:stable
  dependencies:
    - build-deployment-ci-image
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd deployment/ci-base-image
  script:
    - docker load -i ./deployment-ci-image.tar
    - export DEPLOYMENT_CI_VERSION=$(cat version.txt | grep "VERSION" | awk '{print $3}' | sed 's/[,"]//g')
    # Tag as version and push
    - docker tag ${DEPLOYMENT_CI_DOCKER_IMAGE_NAME} ${DEPLOYMENT_CI_DOCKER_IMAGE_NAME}:${DEPLOYMENT_CI_VERSION}
    - docker tag ${DEPLOYMENT_CI_DOCKER_IMAGE_NAME} ${DEPLOYMENT_CI_DOCKER_IMAGE_NAME}:latest
    - docker push ${DEPLOYMENT_CI_DOCKER_IMAGE_NAME}:${DEPLOYMENT_CI_VERSION}
    - docker push ${DEPLOYMENT_CI_DOCKER_IMAGE_NAME}:latest
  except:
    - master

#------------------------ DEPLOY ----------------------------------
# DEPLOY
deploy:
  image: 
    name: ${DEPLOYMENT_CI_DOCKER_IMAGE_NAME}
  dependencies:
    - publish-deployment-ci-image
  stage: deploy
  script:
    - cd deployment
    - python3 ./generate-kubernetes-files.py --output_dir generated-kubernetes-files --template_dir templates --image_tag ${CI_COMMIT_REF_SLUG} ods-${CI_COMMIT_REF_SLUG} /ods/${CI_COMMIT_REF_SLUG}
    - source ./deploy.sh -i generated-kubernetes-files ods-${CI_COMMIT_REF_SLUG}
  when: manual
  environment:
    name: ods-${CI_COMMIT_REF_SLUG}
    url: http://131.188.64.170/ods/${CI_COMMIT_REF_SLUG}
    on_stop: undeploy
  except:
    - master

deploy-master:
  image: 
    name: ${DEPLOYMENT_CI_DOCKER_IMAGE_NAME}
  dependencies:
    - publish-deployment-ci-image
  stage: deploy
  script:
    - cd deployment
    - python3 ./generate-kubernetes-files.py --output_dir generated-kubernetes-files --template_dir templates --image_tag latest ods-${CI_COMMIT_REF_SLUG} /ods/
    - source ./deploy.sh -i generated-kubernetes-files ods-master
  when: manual
  environment:
    name: ods-${CI_COMMIT_REF_SLUG}
    url: http://131.188.64.170/ods/
    on_stop: undeploy
  only:
    - master


undeploy:
  image: 
    name: ${DEPLOYMENT_CI_DOCKER_IMAGE_NAME}
  stage: deploy
  variables:
    GIT_STRATEGY: none
  script:
    - kubectl delete namespaces ods-${CI_COMMIT_REF_SLUG}
  when: manual
  environment:
    name: ods-${CI_COMMIT_REF_SLUG}
    action: stop
