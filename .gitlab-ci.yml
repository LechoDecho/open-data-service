stages:
  - build
  - integrationtest
  - publish

services:
  - docker:dind

# For predefined environment variables see: https://docs.gitlab.com/ee/ci/variables/
variables:
  # Instruct Testcontainers to use the daemon of DinD.
  # See further: https://docs.gitlab.com/ee/ci/docker/using_docker_build.html
  DOCKER_HOST: "tcp://docker:2375"
  # Improve performance with overlayfs.
  # See further: https://docs.docker.com/storage/storagedriver/overlayfs-driver/
  # See further: https://docs.gitlab.com/ee/ci/docker/using_docker_build.html
  DOCKER_DRIVER: "overlay2"
  
  ADAPTER_DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/adapter-service
  UI_DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/ui-service
  SCHEDULER_DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/scheduler-service
  STORAGE_POSTGREST_DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/storage-service-postgrest
  STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/storage-service-liquibase
  TRANSFORMATION_DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/transformation-service
  CORE_DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}/core-service



# ----------------- ADAPTER SERVICE --------------------

# BUILD
build-adapter:
  stage: build
  image: docker:stable
  before_script:
    - cd adapter
  script:
    - docker build -t ${ADAPTER_DOCKER_IMAGE_NAME} .
    - mkdir image # Store built image for following CI steps
    - docker save ${ADAPTER_DOCKER_IMAGE_NAME} > image/adapter.tar
  artifacts:
    expire_in: 1 day
    paths:
      - ./adapter/image/adapter.tar

# INTEGRATION-TEST
integrationtest-adapter:
  stage: integrationtest
  image: mykiwi/docker
  dependencies:
    - build-adapter
  script:
    - docker load -i ./adapter/image/adapter.tar
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml build adapter-service-it
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up -d adapter-service
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up --exit-code-from adapter-service-it adapter-service-it
  after_script:
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml down

# PUBLISH
publish-docker-adapter:
  stage: publish
  image: docker:stable 
  dependencies:
    - build-adapter
  when: manual
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd adapter
  script:
    - docker load -i image/adapter.tar
    - export ADAPTER_VERSION=$(cat ./src/main/resources/application.properties | grep "version =" | awk '{print $3}' | sed "s/[']//g")
    # Tag as version and push
    - docker tag ${ADAPTER_DOCKER_IMAGE_NAME} ${ADAPTER_DOCKER_IMAGE_NAME}:${ADAPTER_VERSION}
    - docker tag ${ADAPTER_DOCKER_IMAGE_NAME} ${ADAPTER_DOCKER_IMAGE_NAME}:latest
    - docker push ${ADAPTER_DOCKER_IMAGE_NAME}:${ADAPTER_VERSION}
    - docker push ${ADAPTER_DOCKER_IMAGE_NAME}:latest


# ----------------- UI SERVICE --------------------

# BUILD
build-ui:
  stage: build
  image: docker:stable
  before_script:
    - cd ui
  script:
    - "docker build -t ${UI_DOCKER_IMAGE_NAME} ."
    - mkdir image # Store built image for following CI steps
    - docker save ${UI_DOCKER_IMAGE_NAME} > image/ui.tar
  artifacts:
    expire_in: 1 day
    paths:
      - ./ui/image

# PUBLISH
publish-docker-ui:
  stage: publish
  image: docker:stable 
  dependencies:
    - build-ui
  when: manual
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd ui
  script:
    - docker load -i ./image/ui.tar
    - export UI_VERSION=$(cat package.json | grep "version" | awk '{print $2}' | sed 's/[,"]//g')
    # Tag as version and push
    - docker tag ${UI_DOCKER_IMAGE_NAME} ${UI_DOCKER_IMAGE_NAME}:${UI_VERSION}
    - docker tag ${UI_DOCKER_IMAGE_NAME} ${UI_DOCKER_IMAGE_NAME}:latest
    - docker push ${UI_DOCKER_IMAGE_NAME}:${UI_VERSION}
    - docker push ${UI_DOCKER_IMAGE_NAME}:latest


# ----------------- Storage SERVICE --------------------

# BUILD
build-storage:
  stage: build
  image: docker:stable
  before_script:
    - cd storage
  script:
    - "docker build -t ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME} ./docker/postgrest/"
    - "docker build -t ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME} ./docker/liquibase/"
    - mkdir image # Store built image for following CI steps
    - docker save ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME} > image/storage_postgrest.tar
    - docker save ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME} > image/storage_liquibase.tar
  artifacts:
    expire_in: 1 day
    paths:
      - ./storage/image


# INTEGRATION-TEST
integrationtest-storage:
  stage: integrationtest
  image: mykiwi/docker
  dependencies:
    - build-storage
  script:
    - docker load -i ./storage/image/storage_postgrest.tar
    - docker load -i ./storage/image/storage_liquibase.tar
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml build storage-service-it
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up -d storage-service-db
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up storage-service-db-liquibase
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up -d storage-service
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up --exit-code-from storage-service-it storage-service-it
  after_script:
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml down


# PUBLISH
publish-docker-storage:
  stage: publish
  image: docker:stable 
  dependencies:
    - build-storage
  when: manual
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd storage
  script:
    - docker load -i ./image/storage_postgrest.tar
    - docker load -i ./image/storage_liquibase.tar
    - export STORAGE_VERSION=$(cat version.txt | grep "VERSION" | awk '{print $3}' | sed 's/[,"]//g')
    # Tag as version and push
    - docker tag ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME} ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME}:${STORAGE_VERSION}
    - docker tag ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME} ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME}:latest
    - docker tag ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME} ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME}:${STORAGE_VERSION}
    - docker tag ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME} ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME}:latest
    - docker push ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME}:${STORAGE_VERSION}
    - docker push ${STORAGE_POSTGREST_DOCKER_IMAGE_NAME}:latest
    - docker push ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME}:${STORAGE_VERSION}
    - docker push ${STORAGE_LIQUIBASE_DOCKER_IMAGE_NAME}:latest


# ----------------- CORE SERVICE --------------------

# BUILD
build-core:
  stage: build
  image: docker:stable
  before_script:
    - cd core
  script:
    - docker build -t ${CORE_DOCKER_IMAGE_NAME} .
    - mkdir image
    - docker save ${CORE_DOCKER_IMAGE_NAME} > image/core.tar
  artifacts:
    expire_in: 1 day
    paths:
      - ./core/image/core.tar

# INTEGRATION-TEST
integrationtest-core:
  stage: integrationtest
  image: mykiwi/docker
  dependencies:
    - build-core
  script:
    - docker load -i ./core/image/core.tar
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml build core-service-it
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up -d core-service
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up --exit-code-from core-service-it core-service-it
  after_script:
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml down


#PUBLISH
public-docker-core:
  stage: publish
  image: docker:stable
  dependencies:
    - build-core
  when: manual
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd core
  script:
    - docker load -i ./image/core.tar
    - export CORE_VERSION=$(cat ./src/main/resources/application.properties | grep "version =" | awk '{print $3}' | sed "s/[']//g")
    # Tag as version and push
    - docker tag ${CORE_DOCKER_IMAGE_NAME} ${CORE_DOCKER_IMAGE_NAME}:${CORE_VERSION}
    - docker tag ${CORE_DOCKER_IMAGE_NAME} ${CORE_DOCKER_IMAGE_NAME}:latest
    - docker push ${CORE_DOCKER_IMAGE_NAME}:${CORE_VERSION}
    - docker push ${CORE_DOCKER_IMAGE_NAME}:latest


# ----------------- Scheduler SERVICE --------------------

# BUILD
build-scheduler:
  stage: build
  image: docker:stable
  before_script:
    - cd scheduler
  script:
    - "docker build -t ${SCHEDULER_DOCKER_IMAGE_NAME} ."
    - mkdir image # Store built image for following CI steps
    - docker save ${SCHEDULER_DOCKER_IMAGE_NAME} > image/scheduler.tar
  artifacts:
    expire_in: 1 day
    paths:
      - ./scheduler/image


# INTEGRATION-TEST
integrationtest-scheduler:
  stage: integrationtest
  image: mykiwi/docker
  dependencies:
    - build-scheduler
  script:
    - docker load -i ./scheduler/image/scheduler.tar
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml build scheduler-service-it
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up -d scheduler-service
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up --exit-code-from scheduler-service-it scheduler-service-it
  after_script:
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml down


# PUBLISH
publish-docker-scheduler:
  stage: publish
  image: docker:stable
  dependencies:
    - build-scheduler
  when: manual
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd scheduler
  script:
    - docker load -i ./image/scheduler.tar
    - export SCHEDULER_VERSION=$(cat package.json | grep "version" | awk '{print $2}' | sed 's/[,"]//g')
    # Tag as version and push
    - docker tag ${SCHEDULER_DOCKER_IMAGE_NAME} ${SCHEDULER_DOCKER_IMAGE_NAME}:${SCHEDULER_VERSION}
    - docker tag ${SCHEDULER_DOCKER_IMAGE_NAME} ${SCHEDULER_DOCKER_IMAGE_NAME}:latest
    - docker push ${SCHEDULER_DOCKER_IMAGE_NAME}:${SCHEDULER_VERSION}
    - docker push ${SCHEDULER_DOCKER_IMAGE_NAME}:latest

# ----------------- Transformation SERVICE --------------------

# BUILD
build-transformation:
  stage: build
  image: docker:stable
  before_script:
    - cd transformation
  script:
    - "docker build -t ${TRANSFORMATION_DOCKER_IMAGE_NAME} ."
    - mkdir image # Store built image for following CI steps
    - docker save ${TRANSFORMATION_DOCKER_IMAGE_NAME} > image/transformation.tar
  artifacts:
    expire_in: 1 day
    paths:
      - ./transformation/image


# INEGRATION-TEST
integrationtest-transformation:
  stage: integrationtest
  image: mykiwi/docker
  dependencies:
    - build-transformation
  script:
    - docker load -i ./transformation/image/transformation.tar
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml build transformation-service-it
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up -d transformation-service
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml up --exit-code-from transformation-service-it transformation-service-it
  after_script:
    - docker-compose -f docker-compose.yml -f docker-compose.ci.yml down


# PUBLISH
publish-docker-transformation:
  stage: publish
  image: docker:stable 
  dependencies:
    - build-transformation
  when: manual
  before_script:
    - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${CI_REGISTRY}
    - cd transformation
  script:
    - docker load -i ./image/transformation.tar
    - export TRANSFORMATION_VERSION=$(cat package.json | grep "version" | awk '{print $2}' | sed 's/[,"]//g')
    # Tag as version and push
    - docker tag ${TRANSFORMATION_DOCKER_IMAGE_NAME} ${TRANSFORMATION_DOCKER_IMAGE_NAME}:${TRANSFORMATION_VERSION}
    - docker tag ${TRANSFORMATION_DOCKER_IMAGE_NAME} ${TRANSFORMATION_DOCKER_IMAGE_NAME}:latest
    - docker push ${TRANSFORMATION_DOCKER_IMAGE_NAME}:${TRANSFORMATION_VERSION}
    - docker push ${TRANSFORMATION_DOCKER_IMAGE_NAME}:latest
